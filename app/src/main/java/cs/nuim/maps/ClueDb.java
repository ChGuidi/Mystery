package cs.nuim.maps;

import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

import static android.R.id.list;

/**
 * Created by kacl2 on 11/19/2016.
 */

public class ClueDb {

    private static final String TABLE_NAME = "Clues_DB";
    private static final String COLUMN_NAME_PLACES = "Places";
    private static final String COLUMN_NAME_VISITED = "Visited";
    private static final String COLUMN_NAME_CLUE = "Clue";
    private static final String COLUMN_NAME_LAT = "Latitude";
    private static final String COLUMN_NAME_LON = "Longitude";
    private static final int DATABASE_VERSION = 1;
    private DbHelper ourHelper;
    private final Context ourContext;
    private SQLiteDatabase ourDatabase;
    private static class DbHelper extends SQLiteOpenHelper {

        private static DbHelper sInstance;

        private DbHelper(Context context) {
            super(context, TABLE_NAME, null, DATABASE_VERSION);
        }

        public static synchronized DbHelper getInstance(Context context) {

            // Use the application context, which will ensure that you
            // don't accidentally leak an Activity's context.
            // See this article for more information: http://bit.ly/6LRzfx
            if (sInstance == null) {
                sInstance = new DbHelper(context.getApplicationContext());
            }
            return sInstance;
        }

        public void onCreate(SQLiteDatabase db) {
            db.execSQL("CREATE TABLE " + TABLE_NAME + " (" +
                    COLUMN_NAME_PLACES + " TEXT NOT NULL, " +
                    COLUMN_NAME_VISITED + " INTEGER NOT NULL, " +
                    COLUMN_NAME_CLUE + " TEXT NOT NULL, " +
                    COLUMN_NAME_LAT + " REAL NOT NULL, " +
                    COLUMN_NAME_LON + " REAL NOT NULL);"
            );
        }

        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            db.execSQL("DROP TABLE IF EXISTS " + TABLE_NAME);
            onCreate(db);
        }
    }


    public ClueDb(Context c) {
        ourContext = c;
    }

    public ClueDb open() throws SQLException {
        ourHelper = DbHelper.getInstance(ourContext);
        ourDatabase = ourHelper.getWritableDatabase();  //will call onCreate() or onUpgrade() or onOpen() above
        return this;
    }

    public void close() {
        ourHelper.close();
    }

    public void createEntry(String place, String clue, double Latitude, double Longitude) {
        // TODO Autogenerated method stub
        ContentValues cv = new ContentValues();
        cv.put(COLUMN_NAME_PLACES, place);
        cv.put(COLUMN_NAME_CLUE, clue);
        cv.put(COLUMN_NAME_VISITED, 0);
        cv.put(COLUMN_NAME_LAT, Latitude);
        cv.put(COLUMN_NAME_LON, Longitude);
        ourDatabase.insert(TABLE_NAME, null, cv);
    }

    public int checkPlaceVisited(String place) throws SQLException { //returns 1 if place has been visited, 0 otherwise
        // TODO Autogenerated method stub
        String[] columns = new String[]{COLUMN_NAME_VISITED};
        //check value of 'visited' column
        Cursor c = ourDatabase.query(TABLE_NAME, columns, COLUMN_NAME_PLACES + "='" + place + "'", null, null, null, null);
        if (!c.isAfterLast()) { //if a valid clue
            c.moveToFirst();
            int isVisited = c.getInt(0);
            c.close();
            return isVisited;
        }
        c.close();
        return -1;
    }

    public int checkClueFound(String clue) throws SQLException { //returns 1 if clue is already found, 0 otherwise
        // TODO Autogenerated method stub
        SharedPreferences prefs = ourContext.getSharedPreferences("GamePreferences",0);
        String killer = prefs.getString("Killer", "PROBLEM");
        String weapon = prefs.getString("Murder Weapon", "PROBLEM");
        String[] columns = new String[]{COLUMN_NAME_VISITED};
        Cursor c = ourDatabase.query(TABLE_NAME, columns, COLUMN_NAME_CLUE + "='" + clue + "'", null, null, null, null);
        if (!c.isAfterLast()) { //if clue is valid and not the murder weapon or killer
            c.moveToFirst();
            int isVisited = c.getInt(0);
            c.close();
            return isVisited;
        }
        else if (clue.equals(killer)||clue.equals(weapon)){ //return 0 if murder weapon or killer
            c.close();
            return 0;
        }
        c.close();
        return -1;
    }

    public String getClue(String place) throws SQLException {
        String[] columns = new String[]{COLUMN_NAME_CLUE};
        Cursor c = ourDatabase.query(TABLE_NAME, columns, COLUMN_NAME_PLACES + "= '" + place + "'", null, null, null, null);
        if (!c.isAfterLast()) {
            c.moveToFirst();
            String clue = c.getString(0);
            c.close();
            return clue;
        }
        c.close();
        return "QUERYERROR";
    }

    //method used to mark locations off as 'visited'
    public void markVisited(String place) throws SQLException {
        ContentValues cvUpdate = new ContentValues();
        cvUpdate.put(COLUMN_NAME_VISITED, 1);
        ourDatabase.update(TABLE_NAME, cvUpdate, COLUMN_NAME_PLACES + "='" + place + "'", null);
    }

    public void setData() {
        open();

        Locations locations = new Locations();
        List<String> suspects = new LinkedList<String>(Arrays.asList(ourContext.getResources().getStringArray(R.array.suspects_array)));
        List<String> weapons = new LinkedList<String>(Arrays.asList(ourContext.getResources().getStringArray(R.array.weapons_array)));

        //randomly select killer, murder weapon, and crime scene. Then prevent them from
        // being assigned locations by removing them from the list
        int killerID = new Random().nextInt(6);
        String killer = suspects.get(killerID);
        suspects.remove(killerID);

        int weaponID = new Random().nextInt(6);
        String weapon = weapons.get(weaponID);
        weapons.remove(weaponID);

        suspects.addAll(weapons); //suspects list now includes suspects and weapons
        Collections.shuffle(suspects); //shuffle so that clues are in different place each time

        List<String> locList = new LinkedList<String>(locations.keySet());
        int locID = new Random().nextInt(locList.size());
        String crimeScene = locList.get(locID);
        locList.remove(locID);

        //fill database with clue locations
        int i = 0;
        for (String s : locations.keySet()) {
            if (crimeScene.equals(s)){
                createEntry(crimeScene, "CRIME SCENE", locations.get(crimeScene).latitude,
                        locations.get(crimeScene).longitude);
            }
            else{
                createEntry(s, suspects.get(i), locations.get(s).latitude, locations.get(s).longitude);
                i++;
            }
        }
        close();
        //put the killer, murder weapon, and criem scene into the shared preferences
        String filename = "GamePreferences";
        SharedPreferences prefs = ourContext.getSharedPreferences(filename,0);
        SharedPreferences.Editor editor = prefs.edit();
        editor.putString("Killer", killer);
        editor.putString("Murder Weapon", weapon);
        editor.putString("Crime Scene", crimeScene);
        editor.apply();
    }

}